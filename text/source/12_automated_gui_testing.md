# Автоматизирано тестване на ГПИ

Проверката за правилно поведение на софтуерия продукт е неизменна част от създаването му. Откриване и поправяне на всички потенциални проблеми преди той да бъде доставен до крайния потребител може да се сметне за най-добрия случай.

### Автоматизирано тестване на Android приложения

Мобилните приложения също имат нужда от проверка на качеството. Поради тази причина, в последните години засилено се разглеждат начини за автоматизацията на подобен вид ръчни тестове. Много голяма част от извършената работа до момента се състои в създаване на входни данни за приложения за мобилната операционна система Android. Подходите използвани до момента, се различават по начина, по който създават входнни данни и изучават и използват евристики за приложението.

#### Съществуващи системи

**Dynodroid** [@machiry2013dynodroid] е инструмент, който се базира на случайно изучаване. Предлага се и ръчен начин за въвеждане на входнни данни, когато системата е заседнала.

**MobiGUITAR** [@amalfitano2015mobiguitar] строи модел на приложението по време на тестване. За всяко ново състояние се поддържа списък с възможни действия, които се изпълняват използвайки DFS (depth first search) стратегия.

**SwiftHand** [@choi2013guided] се опитва да максимизира покритието на код за тестваното приложение. Допълнително, инструментът се старае да минимизира броя рестартирания на приложението. SwiftHand генерира единствено докосвания и скролвания.

**PUMA** [@hao2014puma] предлага обобщена среда за автоматизиране на ГПИ. Инструментът предлага рамка за програмиране, в която могат да бъдат имплементирани различни стратегии за изучаване на тестваното приложение.

#### Покритие на програмен код

Една от основните цели на системите за автоматизирано тестване на софтуер е да постигнат максимално покритие на програмния код. Няколко решения се опитват да постигнат това и за операционната система на Android.

**BBoxTester** [@zhauniarovich2015towards] е рамка за изготвяне на доклади относно покритието на програмния код, без той да бъде наличен. За разлика от други подобни системи, BBoxTester предлага детайлни метрики за покритието на отделни класове, методи и т.н. В основата на системата се използва друг софтуерен продукт - Emma [@roubtsov2005emma]. BBoxTester е система с отворен код, намираща се на [https://github.com/zyrikby/BBoxTester](https://github.com/zyrikby/BBoxTester). За съжаление системата е неподдържана (от 2015г.) и несъвместима с нови версии на Android.

**CovDroid** [@yeh2015covdroid] е друга система за тестване посредством подход на черната кутия (black-box testing). Програмният код на продукта не е наличен. CovDroid изчислява покритието на код като инструментира кода на приложението и използва Android Debug Bridge (adb) за да наблюдава изхода от изпълнение на програмата.

**ABCA** [@huang2015abca] използва подход, много близък до този на CovDroid. Софтуерният пакет може да бъде намерен на [http://cc.ee.ntu.edu.tw/~farn/tools/abca/](http://cc.ee.ntu.edu.tw/~farn/tools/abca/). По време на този обзор, страницата на инструмента не беше активна. Авторите на статията не отговориха на запитването за активен адрес за изтегляне на ABCA.

**GUITracer** [@molnar2015live] представя иновативен подход за визуализация на покритието на код, когато приложението е базирано на ГПИ. Основен недостатък на системата е ограничението за работа върху Java AWT, SWING или SWT рамки за изграждане на ГПИ. Ние предлагаме подход, който няма подобно ограничение.

**GroddDroid** [@abraham2015grodddroid] предлага автоматично намиране и изпълнение на зловреден софтуер (malware). Системата предлага и измерване на покрит код. Софтуерът може да бъде намерен на [http://kharon.gforge.inria.fr/](http://kharon.gforge.inria.fr/). Програмният код е ясно документиран и лесен за употреба. Един недостатък е използването на Logcat монитора за извличане на метрики за покритие на кода. Повечето от горепосочените системи използват този подход.

#### Текущо състояние (State of the art?)

[@choudhary2015automated]

### Проверка на качеството

- Достатъчно бързо ли е? (Model should monitor for speed exec anomalies or report just slow parts)
- Как да повторя грешката? (Provide/execute steps for reproduction)
- Има ли разлики в изходните данни? (Change in hierarchy/image screenshot)
